#!/usr/bin/env python

import argparse
import configparser
import datetime
import fractions
import json
import logging
import math
import os.path
import picamera
import re
import subprocess
import time
import tornado.escape
import tornado.ioloop
import tornado.web

iso_list = (100, 200, 320, 400, 500, 640, 800)

stat_dir = os.path.join(os.path.dirname(__file__), 'static')
img_dir = os.path.join(os.path.dirname(__file__), 'pictures')
img_url = 'pictures/'
#img_dir  = os.path.join(os.path.expanduser('~'),'Pictures')
#name for image files
name_fmt = 'IMG_{num}'

class CameraCfg:
    camera_settings = {'shutter_speed':int, 'iso':int, 'sensor_mode':int, 'framerate':fractions.Fraction}
    main_settings = {'capture_type':str,}

    def __init__(self):
        print('Initializing camera')
        self.camera = picamera.PiCamera(
                    framerate=fractions.Fraction(1,6),
                    sensor_mode=picamera.PiCamera.EXPOSURE_MODES['night'],
                    )
        self.camera.shutter_speed = 6000000
        self.camera.iso = 800
        self.recording = False
        self.capture_type = 'video'
        self.rec_start_time = None
        self.rec_name = None
        #time.sleep(30)
        #print('Camera ready!')

    def take_picture(self, name):
        #TESTING : print name
        print(f'Capturing picture {name}')
        #capture picture
        #TODO : add choice of format
        self.camera.capture(name,format='jpeg')
    
    def start_recording(self, name):
        #TESTING : print name
        print(f'Starting recording to {name}')
        #flag that we are recording
        self.recording = True
        #set recording name
        self.rec_name = name
        #start recording
        self.camera.start_recording(name)
        #save start time
        self.rec_start_time = time.time()
        
    def stop_recording(self):
        #TESTING : print message
        print('Stopping video recording')
        #flag that we are not recording
        self.recording = False
        #clear start time
        self.rec_start_time = None
        #clear file name
        file = self.rec_name
        self.rec_name = None
        #stop the recording
        self.camera.stop_recording()
        #return file name
        return file

    def get_rec_time(self):
        if not self.recording or not self.rec_start_time:
            return None
        #return elapsed time in seconds
        return self.rec_start_time - time.time()

    def save_settings(self, file):
        config = configparser.ConfigParser()

        for s in self.main_settings:
            config['DEFAULT'][s] = getattr(self, s)

        #create camera section
        config['camera'] = {}

        for s in self.camera_settings:
            attr = getattr(self.camera, s)
            config['camera'][s] = str(attr)

        # path is relative too executable
        path = os.path.join(os.path.dirname(__file__), file)

        with open(path,'wt') as fp:
            config.write(fp)

    def load_settings(self,file):

        #skip if file does not exist
        if not os.path.exists(file):
            return

        config = configparser.ConfigParser()

        config.read(file)

        for s, convert_fcn in self.main_settings.items():
            setattr(self, s, convert_fcn(config['DEFAULT'][s]))

        for s, convert_fcn in self.camera_settings.items():
            setattr(self.camera, s, convert_fcn(config['camera'][s]))

    def frame_info(self):
        try:
            dat = self.camera.frame
        except picamera.PiCameraRuntimeError:
            return None

        return dat

            
def num2name(num, ext='.jpg'):
    name = name_fmt.format(num=num) + ext
    return os.path.join(img_dir, name)

def get_pic_num():
    #list files in image dir
    files = os.listdir(img_dir)

    pic_num = 0

    for n in files:
        #search filename for image number
        m = re.search(r'IMG_(?P<num>\d+)\.[A-Za-z0-9]+',n)

        if m:
            num = int(m.group('num'))
            if num > pic_num:
                pic_num = num

    #return the first available number
    return pic_num + 1


def get_img_urls(num):
    name = name_fmt.format(num=num) + '.jpg'
    path = os.path.join(img_dir, name)
    if os.path.exists(path):
        jpg_url = '/' + img_url + name
        #TODO : check if jpg exists and create it if not
        return (jpg_url, jpg_url)
    else:
        #does not exist, return None
        return None

def get_vid_urls(num):
    #TODO: needs a lot of work here. probably needs to convert to a container format to be useable.
    #TODO: detect fake long exposure pictures?
    raw = name_fmt.format(num=num) + '.h264'
    raw_path = os.path.join(img_dir, raw)
    #get converted path
    name = name_fmt.format(num=num) + '.mp4'
    vid_path = os.path.join(img_dir, name)
    if os.path.exists(raw_path):
        raw_url = '/' + img_url + raw
        vid_url = '/' + img_url + name
        #check if containerized video exists
        if not os.path.exists(vid_path):
            #create containerized format with ffmpeg
            cp = subprocess.run(['ffmpeg', '-nostdin', '-probesize', '10M', '-i', raw_path, '-c:v', 'copy', '-f', 'mp4', vid_path])

            if cp.returncode:
                #there was an error
                vid_url = None

        return (vid_url, raw_url)
    else:
        #does not exist, return None
        return None

class StatusHandler(tornado.web.RequestHandler):
    def initialize(self, cam):
        self.cam = cam

    def set_default_headers(self):
        #status is retunded with json
        self.set_header("Content-Type", 'application/json')

    def get(self):
        stat_type = self.get_argument('type', default='frame')

        if stat_type == 'frame':
            info = self.cam.frame_info()

            if info:
                ftime = datetime.timedelta(microseconds=info.timestamp)
                resp = json.dumps({'recording': True, 'index': info.index, 'timestamp': info.timestamp, 'time': str(ftime)})
            else:
                #no frame info, fill in dummy values
                resp = json.dumps({'recording': False, 'index': 0, 'timestamp': ''})
        else:
            raise ValueError(f'Unknown status type : "{stat_type}"')

        self.write(resp)

class ImageDispHandler(tornado.web.RequestHandler):
    def initialize(self):
        pass

    def get(self):
        img_num = self.get_argument('img', default=None)

        if img_num is None:
            self.redirect(r'/gallery.html',True)
        else:
            url = get_img_urls(int(img_num))

            if url:
                jpg_name, raw_name = url

                jpg_url = jpg_name

                print(f'Image path name : {jpg_url}')

                self.render('image.html',img_url=jpg_url)
            else:
                #TODO : give some sort of error here?
                self.redirect(r'/gallery.html',True)

class VideoDispHandler(tornado.web.RequestHandler):
    def initialize(self):
        pass

    def get(self):
        vid_num = self.get_argument('vid', default=None)

        if vid_num is None:
            self.redirect(r'/gallery.html',True)
        else:
            url = get_vid_urls(int(vid_num))

            print(f'get_vid_urls returned : {url}')

            if url:
                vid_name, raw_name = url

                vid_url = vid_name

                print(f'Video path name : {vid_url}')

                self.render('vidpreview.html',vid_url=vid_url)
            else:
                #TODO : give some sort of error here?
                self.redirect(r'/gallery.html',True)

class VideoCapHandler(tornado.web.RequestHandler):
    def initialize(self, cam):
        self.cam = cam

    def get(self):

        self.render('video.html')

    def post(self):

        #get action
        action = self.get_body_argument('action')

        if action == 'stop':
            if self.cam.recording :
                file_name = self.cam.stop_recording()

                m = re.search(r'IMG_(?P<num>\d+)\.[A-Za-z0-9]+',file_name)

                if not m:
                    raise RuntimeError(f'Unable to find image number in : "{file_name}"')
                
                file_num = m.group('num')

                self.redirect(r'/vidpreview.html?vid=' + file_num)
            else:
                self.redirect(r'/gallery.html')
        else:
            #unknown action
            raise RuntimeError(f'Invalid action : "{action}"')

class MainHandler(tornado.web.RequestHandler):
    def initialize(self,cam):
        self.cam = cam

    def get(self):

        #check if we are recording
        if self.cam.recording:
            self.redirect(r'/video.html',True)
            return

        frame = self.cam.camera.framerate

        #divide numerator into denominator
        new_d, rem = divmod(frame.denominator, frame.numerator)

        #check if remainder is small
        if rem < frame.denominator *1e-3:
            #make new fraction
            frame = fractions.Fraction(1, new_d)

        #get shutter speed
        shutter = round(self.cam.camera.shutter_speed*1e-6, 6)

        self.render('index.html',
                        capture_type=self.cam.capture_type, 
                        iso=self.cam.camera.iso,
                        isos=iso_list,
                        mode=self.cam.camera.sensor_mode,
                        shutter=shutter,
                        resolution=self.cam.camera.resolution,
                        frame_d=frame.denominator,
                        frame_n=frame.numerator,
                        awb_mode=self.cam.camera.awb_mode,
                        awb_gain=self.cam.camera.awb_gains,
                   )

    def post(self):
        print(self.request.body)

        #get action
        action = self.get_body_argument('action')

        #update settings
        #get capture type
        self.cam.capture_type =  self.get_body_argument('capture-type')
        #get ISO
        iso = int(self.get_body_argument('iso'))
        print(f'Setting ISO to : {iso}')
        #set ISO
        self.cam.camera.iso = iso

        #get mode
        mode = int(self.get_body_argument('mode'))
        print(f'Setting sensor mode to : {mode}')
        #set mode
        self.cam.camera.sensor_mode = mode

        #get AWB mode
        awb_mode = self.get_body_argument('awb_mode')
        print(f'Setting AWB mode to : {awb_mode}')
        #set mode
        self.cam.camera.awb_mode = awb_mode

        if self.cam.camera.awb_mode == 'off':
            #get AWB red gain
            awb_red = fractions.Fraction(self.get_body_argument('awb_red'))
            #get AWB blue gain
            awb_blue = fractions.Fraction(self.get_body_argument('awb_blue'))
            #set AWB gain
            self.cam.camera.awb_gains = (awb_red, awb_blue)


        #get shutter speed
        shutter = float(self.get_body_argument('shutter'))
        print(f'Setting shutter speed to : {shutter}')
        #set shutter speed
        self.cam.camera.shutter_speed = int(shutter*1e6)

        #get frame rate
        frame_n = int(self.get_body_argument('frame_n'))
        frame_d = int(self.get_body_argument('frame_d'))
        frame = fractions.Fraction(frame_n, frame_d)
        print(f'Setting frame rate to : {frame}')
        #set frame rate
        self.cam.camera.framerate = frame


        #check if we should take a picture
        if action == 'Capture':
            #shutter speed
            shutter_speed = self.cam.camera.shutter_speed*1e-6
            #get redirect time
            redir_time = math.ceil(shutter_speed)
            if self.cam.capture_type == 'video':
                #generate unique file name
                pic_num = get_pic_num()
                pic_name = num2name(pic_num, ext='.h264')
                #capture video
                self.cam.start_recording(pic_name)
                #redirect to video capture page
                self.redirect(r'/video.html',True)
            elif self.cam.capture_type == 'still':
                #generate unique file name
                pic_num = get_pic_num()
                pic_name = num2name(pic_num)
                if shutter_speed<1:
                    #redirect to image page
                    self.redirect(f'/image.html?img={pic_num}', True)
                else:
                    #render redirect page
                    self.render('redirect.html',
                                time=redir_time,
                                picture=pic_num,
                               )
                # take a picture here...
                self.cam.take_picture(pic_name)
            else:
                raise RuntimeError(f'Unknown capture_type "{self.cam.capture_type}"')
        elif action == 'Save':
            #save settings to file
            self.cam.save_settings('settings.cfg')

            self.redirect(r'/',True)
        else:
            raise RuntimeError(f'Unknown action "{action}"')

class Application(tornado.web.Application):
    def __init__(self, cam, *args, **kwargs):
        handlers = [(r"/index", MainHandler,{'cam':cam}),
                    (r"/index\.html", MainHandler,{'cam':cam}),
                    (r"/home\.html", MainHandler,{'cam':cam}),
                    (r"/home", MainHandler,{'cam':cam}),
                    (r"/image.html", ImageDispHandler),
                    (r"/video.html", VideoCapHandler,{'cam':cam}),
                    (r"/vidpreview.html", VideoDispHandler),
                    (r"/status", StatusHandler,{'cam':cam}),
                    (r"/", MainHandler,{'cam':cam}),
                    (r"/" + img_url + "(.*)", tornado.web.StaticFileHandler, {'path': img_dir}),
                ]
        super(Application, self).__init__(handlers, *args, **kwargs)

def start_application():
    parser = argparse.ArgumentParser(description='Web application for camera control')
    parser.add_argument('-p','--port',default=8888,type=int,help='port to listen to')
    parser.add_argument('--debug',action='store_true',help='print additional debug info')

    if not os.path.exists(img_dir):
        print(f'Creating image directory at {img_dir}')
        #make image directory
        os.makedirs(img_dir, exist_ok=True)


    args = parser.parse_args()

    cam = CameraCfg()

    cam.load_settings('settings.cfg')


    app = Application(
                        cam,
                        template_path=os.path.join(os.path.dirname(__file__), 'templates'),
                        static_path=stat_dir,
                        debug = args.debug,
                     )
    app.listen(args.port)
    print(f'Starting server on port {args.port}')
    tornado.ioloop.IOLoop.current().start()

if __name__ == "__main__":
    start_application()

